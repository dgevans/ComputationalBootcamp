g(x) = 2-1.5/(1+x)
x0 = 0.25
diff = 1.
while diff > 1e-6
    global x0,diff
    x1 = g(x0)
    diff = abs(x1 - x0)
    x0 = x1
end
println("The fixed point is: $x0")

f(x) = x - g(x)
a,b = 0.5,1.75
diff = 1
while diff > 1e-6
    global a,b,diff
    c = (a+b)/2
    if f(c) > 0
        b = c
    else
        a = c
    end
    diff = b-a
end
println("Root is $((a+b)/2)")

using Roots
fzero(f,0.5,1.5)

fzero(f,1.)

f(x) = x^3-.05
df(x) = 3*x^2
x0 = 1.
diff = 1.
while diff > 1e-6
    global diff,x0
    x1 = x0 - f(x0)/df(x0)
    x0 = x1
    diff = abs(x1-x0)
end
println("The root is $x0")

using Parameters,Roots,Plots
default(linewidth=2,legend=false,margin=10Plots.mm)
@with_kw mutable struct NCParameters
    A::Float64 = 1.  #Productivity
    α::Float64 = 0.3 #Capital Share of Output
    β::Float64 = 0.96 #Discount Factor
    δ::Float64 = 0.1 #Depreciation Rate
    σ::Float64 = 2.  #1/IES
end;

"""
    compute_steadystate(para::NCParameters)

Computes steady state given parameters stored in para
"""
function compute_steadystate(para::NCParameters)
    @unpack A,α,β,δ,σ = para
    R̄ = 1/β
    k̄ =((R̄ - 1 + δ)/(α * A))^(1/(α-1))

    c̄ = A*k̄^α - δ*k̄

    return c̄,k̄
end;
para =NCParameters()
c̄,k̄ = compute_steadystate(para)

"""
    iterateEuler(para::NCParameters,c,k)

Computes consumption and capital next period that 
satisfies the Euler equation. 
"""
function iterateEuler(para::NCParameters,c,k)::Vector{Float64}
    @unpack A,α,β,δ,σ = para
    k′ = A*k^α + (1-δ)*k - c
    if k′ > 0 #check to see if k′ makes sense
        R′ = α*A*(k′)^(α-1) + 1 -δ

        c′ = (β*R′*c^σ)^(1/σ)
        return [c′,k′]  
    else
        return zeros(2)
    end
end
#check if steady state is a fixed point
iterateEuler(para,c̄,k̄) - [c̄,k̄]

"""
    getshootingpath(para::NCParameters,c0,k0,T=100)

Computes the path generated by iterating on the Euler
equation for T periods.
"""
function getshootingpath(para::NCParameters,c0,k0,T=100)
    k,c = zeros(T),zeros(T)
    c[1],k[1] = c0,k0
    for t in 1:T-1
        c[t+1],k[t+1] = iterateEuler(para,c[t],k[t])
    end

    return (c=c,k=k) #named tuple for easy access
end

plot(getshootingpath(para,c̄+0.001,k̄).k,label="High Initial C",legend=true)
plot!(getshootingpath(para,c̄-0.001,k̄).k,label="Low Initial C",xlabel="Time",ylabel="Capital Stock")

"""
    findoptimal_c(para,k)

Finds the optimal consumption for a given level of capital.  Uses
shooting method with terminal T periods
"""
function findoptimal_c(para::NCParameters,k0,T=100)
    c̄,k̄ = compute_steadystate(para)
    #iterates on the Euler equation for T periods then returns 
    #capital relative to steady state
    function c_res(c0)
        c,k = iterateEuler(para,c0,k0)
        for t in 1:T
            c,k =  iterateEuler(para,c,k)
        end

        return k - k̄
    end
    #use bracketing algorithm
    fzero(c_res,(0.1*c̄,10*c̄))
end
println(findoptimal_c(para,k̄) - c̄)

k0=k̄
plot(getshootingpath(para,findoptimal_c(para,k0),k0).k,xlabel="Time",ylabel="Capital Stock")

k0=0.9*k̄
plot(getshootingpath(para,findoptimal_c(para,k0),k0).k,xlabel="Time",ylabel="Capital Stock")

k0=1.1*k̄
plot(getshootingpath(para,findoptimal_c(para,k0),k0).k,xlabel="Time",ylabel="Capital Stock")

using NLsolve

#consider this function
f(x) = [(x[1]+3)*(x[2]^3-7)+18, sin(x[2]*exp(x[1])-1)];

res = nlsolve(f,[ 0.,0.])
#not_in_place?
println("Did the root solver converge: $(converged(res))")
println("What was the solution: $(res.zero)")
println("Check f at solution: $(f(res.zero))")

#Note fvec is filled with function values
function f!(fvec,x )
    fvec[1] = (x[1]+3)*(x[2]^3-7)+18
    fvec[2] = sin(x[2]*exp(x[1])-1)
end;
#NOTE: NEED DERIVATIVES TO BE EXACT!
function g!(fjac,x)
    fjac[1, 1] = x[2]^3-7
    fjac[1, 2] = 3*x[2]^2*(x[1]+3)
    u = exp(x[1])*cos(x[2]*exp(x[1])-1)
    fjac[2, 1] = x[2]*u
    fjac[2, 2] = u
end;

res = nlsolve(f!,g!,zeros(2))
println("Did the root solver converge: $(converged(res))")
println("What was the solution: $(res.zero)")
println("Check f at solution: $(f(res.zero))")

@time nlsolve(f,zeros(2));
@time nlsolve(f!,g!,zeros(2));

"""
    capitalpath_residual(para,k0::Float64,k::Vector{Float64})

Computes the euler equation errors given a guess of k[t] = kpath[t]
for t <=T and k[t] = k̄ after.
"""
function capitalpath_residual(para::NCParameters,k0::Float64,kpath::Vector{Float64})
    @unpack A,α,β,δ,σ = para
    c̄,k̄ = compute_steadystate(para)
    T = length(kpath)
    k = [k0;kpath;k̄]
    #compute path of c given guess of k
    c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]
    #compute path of R given guess of k
    R = [1-δ+α*A*k[t]^(α-1) for t in 1:T+1]
    uc = c.^(-σ)

    #compute Euler equation residuals
    return uc[1:T] .- β .* R[2:T+1].*uc[2:T+1]
end;

"""
    solveMITshock(para::NCParameters,k0::Float64,T=100)

Finds the perfect forsight equilibrium for a given intial k0
"""
function solveMITshock(para::NCParameters,k0::Float64,T=100)
    @unpack A,α,β,δ,σ = para
    c̄,k̄ = compute_steadystate(para)
    kpath0 = collect(LinRange(k0,k̄,T))# guess a simple linear rule

    result = nlsolve(k->capitalpath_residual(para,k0,k),kpath0)
    if !converged(result)
        error("Could not find root!")
    end

    kpath = result.zero
    k = [k0;kpath;k̄]
    #compute path of c given guess of k
    c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]

    return (c=c,k=k)
end;

k0=0.9*k̄
plot(solveMITshock(para,k0).k[1:100],label="Multivariate Solution",xlabel="Time",ylabel="Capital Stock")
plot!(getshootingpath(para,findoptimal_c(para,k0),k0).k,label="Shooting Algorithm",legend=true)

k0=1.1*k̄
plot(solveMITshock(para,k0).k[1:100],label="Multivariate Solution",xlabel="Time",ylabel="Capital Stock")
plot!(getshootingpath(para,findoptimal_c(para,k0),k0).k,label="Shooting Algorithm",legend=true)

@with_kw mutable struct RBCParameters
    A::Float64 = 1.  #Productivity
    α::Float64 = 0.3 #Capital Share of Output
    β::Float64 = 0.96 #Discount Factor
    δ::Float64 = 0.1 #Depreciation Rate
    σ::Float64 = 2.  #1/IES
    γ::Float64 = 2. #Labor Elasticity
end;