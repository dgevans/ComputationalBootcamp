using Roots
W = 1
T = 0.1
γ = 3.
function findallocation(W,T,γ)
    
    function c_res(lc)
        c = exp(lc)
        l = (W/c)^(1/γ)

        return c - W*l - T
    end

    lc = fzero(c_res,0.0)::Float64
    c = exp(lc)::Float64
    l = (W/c)^(1/γ)

    return c,l
end
c,l = findallocation(W,T,γ)

@show c - W*l - T
@show c
@show l

@benchmark findallocation(W,T,γ)

#why global is bad?
function fres(lc)
    c = exp(lc)
    l = (W/c)^(1/γ)

    return c - W*l - T
end
@benchmark fzero(fres,0.0)
fres(0.0)


#find square root of 2
function fres(x)
    return x^2 - 2
end

x = fzero(fres,0.0)
@show x
@show x^2



using Parameters,Roots,Plots
default(linewidth=2,legend=false,margin=10Plots.mm)
@with_kw mutable struct NCParameters
    A::Float64 = 1.  #Productivity
    α::Float64 = 0.3 #Capital Share of Output
    β::Float64 = 0.96 #Discount Factor
    δ::Float64 = 0.1 #Depreciation Rate
    σ::Float64 = 2.  #1/IES
end;

"""
    compute_steadystate(para::NCParameters)

Computes steady state given parameters stored in para
"""
function compute_steadystate(para::NCParameters)
    @unpack A,α,β,δ,σ = para
    R̄ = 1/β
    k̄ =((R̄ - 1 + δ)/(α * A))^(1/(α-1))

    c̄ = A*k̄^α - δ*k̄

    return c̄,k̄
end;
para =NCParameters()
c̄,k̄ = compute_steadystate(para)


"""
    iterateEuler(para::NCParameters,c,k)

Computes consumption and capital next period that 
satisfies the Euler equation. 
"""
function iterateEuler(para::NCParameters,c,k)::Vector{Float64}
    @unpack A,α,β,δ,σ = para
    k′ = A*k^α + (1-δ)*k - c
    if k′ > 0 #check to see if k′ makes sense
        R′ = α*A*(k′)^(α-1) + 1 -δ

        c′ = (β*R′*c^σ)^(1/σ)
        return [c′,k′]  
    else
        return zeros(2)
    end
end
#check if steady state is a fixed point
@show iterateEuler(para,c̄,k̄) - [c̄,k̄]

"""
    getshootingpath(para::NCParameters,c0,k0,T=100)

Computes the path generated by iterating on the Euler
equation for T periods.
"""
function getshootingpath(para::NCParameters,c0,k0,T=100)
    k,c = zeros(T),zeros(T)
    c[1],k[1] = c0,k0
    for t in 1:T-1
        c[t+1],k[t+1] = iterateEuler(para,c[t],k[t])
    end

    return (c=c,k=k) #named tuple for easy access
end

getshootingpath(para,c̄,k̄).k

plot(getshootingpath(para,c̄,k̄).k,xlabel="Time",ylabel="Capital Stock")
plot!(getshootingpath(para,c̄+0.001,k̄).k,xlabel="Time",ylabel="Capital Stock")
plot!(getshootingpath(para,c̄-0.001,k̄).k,xlabel="Time",ylabel="Capital Stock")

"""
    findoptimal_c(para,k)

Finds the optimal consumption for a given level of capital.  Uses
shooting method with terminal T periods
"""
function findoptimal_c(para::NCParameters,k0,T=100)
    c̄,k̄ = compute_steadystate(para)
    #iterates on the Euler equation for T periods then returns 
    #capital relative to steady state
    function c_res(c0)
        c,k = iterateEuler(para,c0,k0)
        for t in 1:T
            c,k =  iterateEuler(para,c,k)
        end

        return k - k̄
    end
    #use bracketing algorithm
    fzero(c_res,(0.1*c̄,10*c̄))
end
println(findoptimal_c(para,k̄) - c̄)

findoptimal_c(para,k̄-0.5)

k0=0.9*k̄
plot(getshootingpath(para,findoptimal_c(para,k0),k0).k,xlabel="Time",ylabel="Capital Stock")
plot!(getshootingpath(para,findoptimal_c(para,k0)-.000001,k0).k,xlabel="Time",ylabel="Capital Stock")
plot!(getshootingpath(para,findoptimal_c(para,k0)+.000001,k0).k,xlabel="Time",ylabel="Capital Stock")


using NLsolve

#consider this function
f(x) = [(x[1]+3)*(x[2]^3-7)+18, sin(x[2]*exp(x[1])-1)];

res = nlsolve(f,[ 0.,0.])

"""
    capitalpath_residual(para,k0::Float64,k::Vector{Float64})

Computes the euler equation errors given a guess of k[t] = kpath[t]
for t <=T and k[t] = k̄ after.
"""
function capitalpath_residual(para::NCParameters,k0::Float64,kpath::Vector{Float64})
    @unpack A,α,β,δ,σ = para
    c̄,k̄ = compute_steadystate(para)
    T = length(kpath)
    k = [k0;kpath;k̄]
    #compute path of c given guess of k
    c = [A*k[t]^α + (1-δ)*k[t] - k[t+1] for t in 1:T+1]
    #compute path of R given guess of k
    R = [1-δ+α*A*k[t]^(α-1) for t in 1:T+1]
    uc = c.^(-σ)

    #compute Euler equation residuals
    return [uc[t] - β .* R[t+1].*uc[t+1] for t in 1:T]
end;

k0 = 0.9*k̄
kpath0 = collect(LinRange(k0,k̄,100))

capitalpath_residual(para,k0,kpath0)
kres = kpath->capitalpath_residual(para,k0,kpath)
res =nlsolve( kres,kpath0)


function ftest(a,b)
    return a^2 + b^2 - 1
end

ftest(1.,1.)

b0 = 0.5
fa = a->ftest(a,b0)
fa(1.)

fzero(fa,0.0)


using NLopt

function f!(x::Vector, grad::Vector)
    if length(grad) > 0
        grad[1] = 0
        grad[2] = 0.5/sqrt(x[2])
    end

    return sqrt(x[2])
end

function g1!(x::Vector, grad::Vector)
    if length(grad) > 0
        grad[1] = -3*(-x[1]+1)^2
        grad[2] = -1
    end
    return (-x[1]+1)^3 - x[2]   
end

function g2!(x::Vector, grad::Vector)
    if length(grad) > 0
        grad[1] = 6*(2x[1])^2
        grad[2] = -1
    end
    return (2x[1])^3 - x[2]
end

opt = Opt(:LD_MMA, 2)
lower_bounds!(opt, [-Inf, 0.])
ftol_abs!(opt,1e-6)

min_objective!(opt, f!)
inequality_constraint!(opt, g1!)
inequality_constraint!(opt, g2!)

(minf,minx,ret) = NLopt.optimize(opt, [3., 1.])
println("got $minf at $minx after $count iterations (returned $ret)")